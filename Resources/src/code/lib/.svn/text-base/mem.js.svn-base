require('src/include/require_once').monkeypatch(this)
var os       = require('src/code/lib/os')
var variable = require('src/code/lib/var')
var exports  = exports || {}

	function free(obj)
	{ // delete only tells GC that obj is available, so we merely rename it
//		if        (obj)
			delete obj
	return         obj 
	}exports.free = free

	function undefine(obj)
	{
		   obj = undefined // JS works by reference, sw33t!
	return obj
	}exports.undefine = undefine

	function nullify(obj)
	{
		   obj = null
	return obj 
	}exports.nullify = nullify

// a little bit of syntatic sugar
	function remove(obj) { return exports.undefine(obj) }
	 exports.remove = remove

	function clear(obj)  { return exports.nullify(obj) }
	 exports.clear = clear

	function dealloc(obj)
	{
Ti.API.info( ' > DeAllocating ' + obj )
exports.clear (obj)	// set it to null, to remove the info within (or the reference)
exports.remove(obj)	// finally, undefine it so there is no trace
exports.free  (obj) // tell the GC that it can use that memory (only works for objects and properties!!)
	return     obj
	}exports.dealloc = dealloc

	function clobber(obj)
	{
		for ( property in obj )
		{
	exports.dealloc( obj[property] )
		}
	return exports.dealloc(obj)
	}exports.clobber = clobber

	function obliterate( obj, level )
	{// When we delete an object, we don't delete its properties, so we will iterate to oblitearte
		var level = level || 0
		if ( level < 100 )
		{// quick control to prevent infinite recursion
			for ( property in obj )
			{// since delete foo doesn't remove foo.bar... we remove every property
				if (  isNaN( parseInt(property) )  )
				{// TODO This is still kind of dark magic to me, but its better than not trying
	obliterate( obj[property], level )
				}
			}
		}// if it passed this point, then it doesn't have any more properties
	return exports.dealloc(obj)
	}exports.obliterate = obliterate

	function RAM() { return 'RAM: ' + Ti.Platform.availableMemory }
	 exports.RAM = RAM

	function dispose(obj)
	{// TODO android doesn't like the obliterate process, so we fed him the clobber
Ti.API.info( '>>> Disposing ' + obj + ' ' + exports.RAM() )
		var result = (os.isAndroid) ? exports.clobber(obj) : exports.obliterate(obj)
Ti.API.info( '>>> Disposed '  + obj + ' ' + exports.RAM() )
	return  result
	}exports.dispose = dispose
